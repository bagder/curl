/***************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution. The terms
 * are also available at https://fetch.se/docs/copyright.html.
 *
 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 * copies of the Software, and permit persons to whom the Software is
 * furnished to do so, under the terms of the COPYING file.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 * SPDX-License-Identifier: fetch
 *
 ***************************************************************************/
#include "tool_setup.h"

#include "fetchx.h"
#include "tool_cfgable.h"
#include "tool_cb_dbg.h"
#include "tool_msgs.h"
#include "tool_setopt.h"
#include "tool_ssls.h"
#include "dynbuf.h"
#include "fetch_base64.h"
#include "fetch_get_line.h"

/* The maximum line length for an ecoded session ticket */
#define MAX_SSLS_LINE (64 * 1024)


static FETCHcode tool_ssls_easy(struct GlobalConfig *global,
                               struct OperationConfig *config,
                               FETCHSH *share, FETCH **peasy)
{
  FETCHcode result = FETCHE_OK;

  *peasy = fetch_easy_init();
  if(!*peasy)
    return FETCHE_OUT_OF_MEMORY;

  result = fetch_easy_setopt(*peasy, FETCHOPT_SHARE, share);
  if(!result && (global->tracetype != TRACE_NONE)) {
    my_setopt(*peasy, FETCHOPT_DEBUGFUNCTION, tool_debug_cb);
    my_setopt(*peasy, FETCHOPT_DEBUGDATA, config);
    my_setopt(*peasy, FETCHOPT_VERBOSE, 1L);
  }
  return result;
}

FETCHcode tool_ssls_load(struct GlobalConfig *global,
                        struct OperationConfig *config,
                        FETCHSH *share, const char *filename)
{
  FILE *fp;
  FETCH *easy = NULL;
  struct dynbuf buf;
  unsigned char *shmac = NULL, *sdata = NULL;
  char *c, *line, *end;
  size_t shmac_len, sdata_len;
  FETCHcode r = FETCHE_OK;
  int i, imported;

  fetchx_dyn_init(&buf, MAX_SSLS_LINE);
  fp = fopen(filename, FOPEN_READTEXT);
  if(!fp) { /* ok if it does not exist */
    notef(global, "SSL session file does not exist (yet?): %s", filename);
    goto out;
  }

  r = tool_ssls_easy(global, config, share, &easy);
  if(r)
    goto out;

  i = imported = 0;
  while(Curl_get_line(&buf, fp)) {
    ++i;
    fetch_free(shmac);
    fetch_free(sdata);
    line = Curl_dyn_ptr(&buf);
    while(*line && ISBLANK(*line))
      line++;
    if(*line == '#')
      /* skip commented lines */
      continue;

    c = memchr(line, ':', strlen(line));
    if(!c) {
      warnf(global, "unrecognized line %d in ssl session file %s",
            i, filename);
      continue;
    }
    *c = '\0';
    r = fetchx_base64_decode(line, &shmac, &shmac_len);
    if(r) {
      warnf(global, "invalid shmax base64 encoding in line %d", i);
      continue;
    }
    line = c + 1;
    end = line + strlen(line) - 1;
    while((end > line) && (*end == '\n' || *end == '\r' || ISBLANK(*line))) {
      *end = '\0';
      --end;
    }
    r = fetchx_base64_decode(line, &sdata, &sdata_len);
    if(r) {
      warnf(global, "invalid sdata base64 encoding in line %d: %s", i, line);
      continue;
    }

    r = fetch_easy_ssls_import(easy, NULL, shmac, shmac_len, sdata, sdata_len);
    if(r) {
      warnf(global, "import of session from line %d rejected(%d)", i, r);
      continue;
    }
    ++imported;
  }
  r = FETCHE_OK;

out:
  if(easy)
    fetch_easy_cleanup(easy);
  if(fp)
    fclose(fp);
  fetchx_dyn_free(&buf);
  fetch_free(shmac);
  fetch_free(sdata);
  return r;
}

struct tool_ssls_ctx {
  struct GlobalConfig *global;
  FILE *fp;
  int exported;
};

static FETCHcode tool_ssls_exp(FETCH *easy, void *userptr,
                              const char *session_key,
                              const unsigned char *shmac, size_t shmac_len,
                              const unsigned char *sdata, size_t sdata_len,
                              fetch_off_t valid_until, int ietf_tls_id,
                              const char *alpn, size_t earlydata_max)
{
  struct tool_ssls_ctx *ctx = userptr;
  char *enc = NULL;
  size_t enc_len;
  FETCHcode r;

  (void)easy;
  (void)valid_until;
  (void)ietf_tls_id;
  (void)alpn;
  (void)earlydata_max;
  if(!ctx->exported)
    fputs("# Your SSL session cache. https://fetch.se/docs/ssl-sessions.html\n"
        "# This file was generated by libfetch! Edit at your own risk.\n",
        ctx->fp);

  r = fetchx_base64_encode((const char *)shmac, shmac_len, &enc, &enc_len);
  if(r)
    goto out;
  r = FETCHE_WRITE_ERROR;
  if(enc_len != fwrite(enc, 1, enc_len, ctx->fp))
    goto out;
  if(EOF == fputc(':', ctx->fp))
    goto out;
  fetch_free(enc);
  r = fetchx_base64_encode((const char *)sdata, sdata_len, &enc, &enc_len);
  if(r)
    goto out;
  r = FETCHE_WRITE_ERROR;
  if(enc_len != fwrite(enc, 1, enc_len, ctx->fp))
    goto out;
  if(EOF == fputc('\n', ctx->fp))
    goto out;
  r = FETCHE_OK;
  ctx->exported++;
out:
  if(r)
    warnf(ctx->global, "Warning: error saving SSL session for '%s': %d",
          session_key, r);
  fetch_free(enc);
  return r;
}

FETCHcode tool_ssls_save(struct GlobalConfig *global,
                        struct OperationConfig *config,
                        FETCHSH *share, const char *filename)
{
  struct tool_ssls_ctx ctx;
  FETCH *easy = NULL;
  FETCHcode r = FETCHE_OK;

  ctx.global = global;
  ctx.exported = 0;
  ctx.fp = fopen(filename, FOPEN_WRITETEXT);
  if(!ctx.fp) {
    warnf(global, "Warning: Failed to create SSL session file %s", filename);
    goto out;
  }

  r = tool_ssls_easy(global, config, share, &easy);
  if(r)
    goto out;

  r = fetch_easy_ssls_export(easy, tool_ssls_exp, &ctx);

out:
  if(easy)
    fetch_easy_cleanup(easy);
  if(ctx.fp)
    fclose(ctx.fp);
  return r;
}
