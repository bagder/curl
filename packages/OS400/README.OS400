
Implementation notes:

  This is a true OS/400 ILE implementation, not a PASE implementation (for
PASE, use AIX implementation).

  The biggest problem with OS/400 is EBCDIC. libfetch implements an internal
conversion mechanism, but it has been designed for computers that have a
single native character set. OS/400 default native character set varies
depending on the country for which it has been localized. Further, a job
may dynamically alter its "native" character set.
  Several characters that do not have fixed code in EBCDIC variants are
used in libfetch strings. As a consequence, using the existing conversion
mechanism would have lead in a localized binary library - not portable across
countries.
  For this reason, and because libfetch was originally designed for ASCII based
operating systems, the current OS/400 implementation uses ASCII as internal
character set. This has been accomplished using the QADRT library and
include files, a C and system procedures ASCII wrapper library. See IBM QADRT
description for more information.
  This then results in libfetch being an ASCII library: any function string
argument is taken/returned in ASCII and a C/C++ calling program built around
QADRT may use libfetch functions as on any other platform.
  QADRT does not define ASCII wrappers for all C/system procedures: the
OS/400 configuration header file and an additional module (os400sys.c) define
some more of them, that are used by libfetch and that QADRT left out.
  To support all the different variants of EBCDIC, non-standard wrapper
procedures have been added to libfetch on OS/400: they provide an additional
CCSID (numeric Coded Character Set ID specific to OS/400) parameter for each
string argument. Callback procedures arguments giving access to strings are
NOT converted, so text gathered this way is (probably !) ASCII.

  Another OS/400 problem comes from the fact that the last fixed argument of a
vararg procedure may not be of type char, unsigned char, short or unsigned
short. Enums that are internally implemented by the C compiler as one of these
types are also forbidden. libfetch uses enums as vararg procedure tagfields...
Happily, there is a pragma forcing enums to type "int". The original libfetch
header files are thus altered during build process to use this pragma, in
order to force libfetch enums of being type int (the pragma disposition in use
before inclusion is restored before resuming the including unit compilation).

  Non-standard EBCDIC wrapper prototypes are defined in an additional header
file: ccsidfetch.h. These should be self-explanatory to an OS/400-aware
designer. CCSID 0 can be used to select the current job's CCSID.
  Wrapper procedures with variable arguments are described below:

_ fetch_easy_setopt_ccsid()
  Variable arguments are a string pointer and a CCSID (unsigned int) for
options:
        FETCHOPT_ABSTRACT_UNIX_SOCKET
        FETCHOPT_ACCEPT_ENCODING
        FETCHOPT_ALTSVC
        FETCHOPT_AWS_SIGV4
        FETCHOPT_CAINFO
        FETCHOPT_CAPATH
        FETCHOPT_COOKIE
        FETCHOPT_COOKIEFILE
        FETCHOPT_COOKIEJAR
        FETCHOPT_COOKIELIST
        FETCHOPT_CRLFILE
        FETCHOPT_CUSTOMREQUEST
        FETCHOPT_DEFAULT_PROTOCOL
        FETCHOPT_DNS_INTERFACE
        FETCHOPT_DNS_LOCAL_IP4
        FETCHOPT_DNS_LOCAL_IP6
        FETCHOPT_DNS_SERVERS
        FETCHOPT_DOH_URL
        FETCHOPT_EGDSOCKET
        FETCHOPT_FTPPORT
        FETCHOPT_FTP_ACCOUNT
        FETCHOPT_FTP_ALTERNATIVE_TO_USER
        FETCHOPT_HAPROXY_CLIENT_IP
        FETCHOPT_HSTS
        FETCHOPT_INTERFACE
        FETCHOPT_ISSUERCERT
        FETCHOPT_KEYPASSWD
        FETCHOPT_KRBLEVEL
        FETCHOPT_LOGIN_OPTIONS
        FETCHOPT_MAIL_AUTH
        FETCHOPT_MAIL_FROM
        FETCHOPT_NETRC_FILE
        FETCHOPT_NOPROXY
        FETCHOPT_PASSWORD
        FETCHOPT_PINNEDPUBLICKEY
        FETCHOPT_PRE_PROXY
        FETCHOPT_PROTOCOLS_STR
        FETCHOPT_PROXY
        FETCHOPT_PROXYPASSWORD
        FETCHOPT_PROXYUSERNAME
        FETCHOPT_PROXYUSERPWD
        FETCHOPT_PROXY_CAINFO
        FETCHOPT_PROXY_CAPATH
        FETCHOPT_PROXY_CRLFILE
        FETCHOPT_PROXY_ISSUERCERT
        FETCHOPT_PROXY_KEYPASSWD
        FETCHOPT_PROXY_PINNEDPUBLICKEY
        FETCHOPT_PROXY_SERVICE_NAME
        FETCHOPT_PROXY_SSLCERT
        FETCHOPT_PROXY_SSLCERTTYPE
        FETCHOPT_PROXY_SSLKEY
        FETCHOPT_PROXY_SSLKEYTYPE
        FETCHOPT_PROXY_SSL_CIPHER_LIST
        FETCHOPT_PROXY_TLS13_CIPHERS
        FETCHOPT_PROXY_TLSAUTH_PASSWORD
        FETCHOPT_PROXY_TLSAUTH_TYPE
        FETCHOPT_PROXY_TLSAUTH_USERNAME
        FETCHOPT_RANDOM_FILE
        FETCHOPT_RANGE
        FETCHOPT_REDIR_PROTOCOLS_STR
        FETCHOPT_REFERER
        FETCHOPT_REQUEST_TARGET
        FETCHOPT_RTSP_SESSION_ID
        FETCHOPT_RTSP_STREAM_URI
        FETCHOPT_RTSP_TRANSPORT
        FETCHOPT_SASL_AUTHZID
        FETCHOPT_SERVICE_NAME
        FETCHOPT_SOCKS5_GSSAPI_SERVICE
        FETCHOPT_SSH_HOST_PUBLIC_KEY_MD5
        FETCHOPT_SSH_HOST_PUBLIC_KEY_SHA256
        FETCHOPT_SSH_KNOWNHOSTS
        FETCHOPT_SSH_PRIVATE_KEYFILE
        FETCHOPT_SSH_PUBLIC_KEYFILE
        FETCHOPT_SSLCERT
        FETCHOPT_SSLCERTTYPE
        FETCHOPT_SSLENGINE
        FETCHOPT_SSLKEY
        FETCHOPT_SSLKEYTYPE
        FETCHOPT_SSL_CIPHER_LIST
        FETCHOPT_SSL_EC_CURVES
        FETCHOPT_TLS13_CIPHERS
        FETCHOPT_TLSAUTH_PASSWORD
        FETCHOPT_TLSAUTH_TYPE
        FETCHOPT_TLSAUTH_USERNAME
        FETCHOPT_UNIX_SOCKET_PATH
        FETCHOPT_URL
        FETCHOPT_USERAGENT
        FETCHOPT_USERNAME
        FETCHOPT_USERPWD
        FETCHOPT_XOAUTH2_BEARER
  All blob options are also supported.
  In all other cases, it ignores the ccsid parameter and behaves as
fetch_easy_setopt().
  Note that FETCHOPT_ERRORBUFFER is not in the list above, since it gives the
address of an (empty) character buffer, not the address of a string.
FETCHOPT_POSTFIELDS stores the address of static binary data (of type void *)
and thus is not converted. If FETCHOPT_COPYPOSTFIELDS is issued after
FETCHOPT_POSTFIELDSIZE != -1, the data size is adjusted according to the
CCSID conversion result length.

_ fetch_formadd_ccsid()
  In the variable argument list, string pointers should be followed by a (long)
CCSID for the following options:
        FETCHFORM_BUFFER
        FETCHFORM_CONTENTTYPE
        FETCHFORM_COPYCONTENTS
        FETCHFORM_COPYNAME
        FETCHFORM_FILE
        FETCHFORM_FILECONTENT
        FETCHFORM_FILENAME
        FETCHFORM_PTRNAME
  If taken from an argument array, an additional array entry must follow each
entry containing one of the above option. This additional entry holds the CCSID
in its value field, and the option field is meaningless.
  It is not possible to have a string pointer and its CCSID across a function
parameter/array boundary.
  Please note that FETCHFORM_PTRCONTENTS and FETCHFORM_BUFFERPTR are considered
unconvertible strings and thus are NOT followed by a CCSID.

_ fetch_easy_getinfo_ccsid()
  The following options are followed by a 'char * *' and a CCSID. Unlike
fetch_easy_getinfo(), the value returned in the pointer should be released with
fetch_free() after use:
        FETCHINFO_CONTENT_TYPE
        FETCHINFO_EFFECTIVE_URL
        FETCHINFO_FTP_ENTRY_PATH
        FETCHINFO_LOCAL_IP
        FETCHINFO_PRIMARY_IP
        FETCHINFO_REDIRECT_URL
        FETCHINFO_REFERER
        FETCHINFO_RTSP_SESSION_ID
        FETCHINFO_SCHEME
  Likewise, the following options are followed by a struct fetch_slist * * and a
CCSID.
        FETCHINFO_COOKIELIST
        FETCHINFO_SSL_ENGINES
Lists returned should be released with fetch_slist_free_all() after use.
  Option FETCHINFO_CERTINFO is followed by a struct fetch_certinfo * * and a
CCSID. Returned structures should be freed with fetch_certinfo_free_all()
after use.
  Other options are processed like in fetch_easy_getinfo().

_ fetch_easy_strerror_ccsid(), fetch_multi_strerror_ccsid(),
fetch_share_strerror_ccsid() and fetch_url_strerror_ccsid() work as their
non-ccsid version and return a string encoded in the additional ccsid
parameter. These strings belong to libfetch and may not be freed by the caller.
A subsequent call to the same procedure in the same thread invalidates the
previous result.

_ fetch_pushheader_bynum_cssid() and fetch_pushheader_byname_ccsid()
  Although the prototypes are self-explanatory, the returned string pointer
should be released with fetch_free() after use, as opposite to the non-ccsid
versions of these procedures.
  Please note that HTTP2 is not (yet) implemented on OS/400, thus these
functions always return NULL.

_ fetch_easy_option_by_name_ccsid() returns a pointer to an untranslated option
metadata structure. As each fetch_easyoption structure holds the option name in
ASCII, the fetch_easy_option_get_name_ccsid() function allows getting it in any
supported ccsid. However the caller should release the returned pointer with
fetch_free() after use.

_ fetch_easy_header_ccsid() works as its non-CCSID counterpart but requires an
additional ccsid parameter specifying the name parameter encoding. The output
hout parameter is kept in libfetch's encoding and should not be altered.

_ fetch_from_ccsid() and fetch_to_ccsid() are string encoding conversion
functions between ASCII (latin1) and the given CCSID. The first parameter is
the source string, the second is the CCSID and the returned value is a pointer
to the dynamically allocated string. These functions do not impact on fetch's
behavior and are only provided for user convenience. After use, returned values
must be released with fetch_free().


  Standard compilation environment does support neither autotools nor make; in
fact, few common utilities are available. As a consequence, the config-os400.h
has been coded manually and the compilation scripts are a set of shell scripts
stored in subdirectory packages/OS400.

  The test environment is currently not supported on OS/400.


Protocols currently implemented on OS/400:
_ DICT
_ FILE
_ FTP
_ FTPS
_ FTP with secure transmission
_ GOPHER
_ HTTP
_ HTTPS
_ IMAP
_ IMAPS
_ IMAP with secure transmission
_ LDAP
_ POP3
_ POP3S
_ POP3 with secure transmission
_ RTSP
_ SCP if libssh2 is enabled
_ SFTP if libssh2 is enabled
_ SMTP
_ SMTPS
_ SMTP with secure transmission
_ TELNET
_ TFTP



Compiling on OS/400:

  These instructions targets people who knows about OS/400, compiling, IFS and
archive extraction. Do not ask questions about these subjects if you are not
familiar with.

_ As a prerequisite, QADRT development environment must be installed.
  For more information on downloading and installing the QADRT development kit,
  please see https://www.ibm.com/support/pages/node/6258183
_ If data compression has to be supported, ZLIB development environment must
  be installed.
_ Likewise, if SCP and SFTP protocols have to be compiled in, LIBSSH2
  developent environment must be installed.
_ Install the fetch source directory in IFS. Do NOT install it in the
  installation target directory (which defaults to /fetch).
_ Enter Qshell (QSH, not PASE)
_ Change current directory to the fetch installation directory
_ Change current directory to ./packages/OS400
- If you want to change the default configuration parameters like debug info
  generation, optimization level, listing option, target library, ZLIB/LIBSSH2
  availability and location, etc., copy file config400.default to
  config400.override and edit the latter. Do not edit the original default file
  as it might be overwritten by a subsequent source installation.
_ Copy any file in the current directory to makelog (i.e.:
  cp initscript.sh makelog): this is intended to create the makelog file with
  an ASCII CCSID!
_ Enter the command "sh makefile.sh > makelog 2>&1"
_ Examine the makelog file to check for compilation errors. CZM0383 warnings on
  C or system standard API come from QADRT inlining and can safely be ignored.

  Without configuration parameters override, this produces the following
OS/400 objects:
_ libfetch. All other objects are stored in this library.
_ Modules for all libfetch units.
_ Binding directory FETCH_A, to be used at calling program link time for
  statically binding the modules (specify BNDSRVPGM(QADRTTS QGLDCLNT QGLDBRDR)
  when creating a program using FETCH_A).
_ Service program FETCH.<soname>, where <soname> is extracted from the
  lib/Makefile.am VERSION variable. To be used at calling program runtime
  when this program has dynamically bound fetch at link time.
_ Binding directory FETCH. To be used to dynamically bind libfetch when linking a
  calling program.
- CLI tool bound program fetch.
- CLI command fetch.
_ Source file H. It contains all the include members needed to compile a C/C++
  module using libfetch, and an ILE/RPG /copy member for support in this
  language.
_ Standard C/C++ libfetch include members in file H.
_ CCSIDFETCH member in file H. This defines the non-standard EBCDIC wrappers for
  C and C++.
_ FETCH.INC member in file H. This defines everything needed by an ILE/RPG
  program using libfetch.
_ IFS directory /fetch/include/fetch containing the C header files for IFS source
  C/C++ compilation and fetch.inc.rpgle for IFS source ILE/RPG compilation.
- IFS link /fetch/bin/fetch to CLI tool program.


Special programming consideration:

QADRT being used, the following points must be considered:
_ If static binding is used, service program QADRTTS must be linked too.
_ The EBCDIC CCSID used by QADRT is 37 by default, NOT THE JOB'S CCSID. If
  another EBCDIC CCSID is required, it must be set via a locale through a call
  to setlocale_a (QADRT's setlocale() ASCII wrapper) with category LC_ALL or
  LC_CTYPE, or by setting environment variable QADRT_ENV_LOCALE to the locale
  object path before executing the program.
_ Do not use original source include files unless you know what you are doing.
  Use the installed members instead (in /QSYS.LIB/FETCH.LIB/H.FILE and
  /fetch/include/fetch).



ILE/RPG support:

  Since most of the ILE OS/400 programmers use ILE/RPG exclusively, a
definition /INCLUDE member is provided for this language. To include all
libfetch definitions in an ILE/RPG module, line

     h bnddir('FETCH/FETCH')

must figure in the program header, and line

     d/include fetch/h,fetch.inc

in the global data section of the module's source code.

  No vararg procedure support exists in ILE/RPG: for this reason, the following
considerations apply:
_ Procedures fetch_easy_setopt_long(), fetch_easy_setopt_object(),
  fetch_easy_setopt_function(), fetch_easy_setopt_offset() and
  fetch_easy_setopt_blob() are all alias prototypes to fetch_easy_setopt(), but
  with different parameter lists.
_ Procedures fetch_easy_getinfo_string(), fetch_easy_getinfo_long(),
  fetch_easy_getinfo_double(), fetch_easy_getinfo_slist(),
  fetch_easy_getinfo_ptr(), fetch_easy_getinfo_socket() and
  fetch_easy_getinfo_off_t() are all alias prototypes to fetch_easy_getinfo(),
  but with different parameter lists.
_ Procedures fetch_multi_setopt_long(), fetch_multi_setopt_object(),
  fetch_multi_setopt_function() and fetch_multi_setopt_offset() are all alias
  prototypes to fetch_multi_setopt(), but with different parameter lists.
_ Procedures fetch_share_setopt_int(), fetch_share_setopt_ptr() and
  fetch_share_setopt_proc() are all alias prototypes to fetch_share_setopt,
  but with different parameter lists.
_ Procedure fetch_easy_setopt_blob_ccsid() is an alias of
  fetch_easy_setopt_ccsid() supporting blob encoding conversion.
_ The prototype of procedure fetch_formadd() allows specifying a pointer option
  and the FETCHFORM_END option. This makes possible to use an option array
  without any additional definition. If some specific incompatible argument
  list is used in the ILE/RPG program, the latter must define a specialised
  alias. The same applies to fetch_formadd_ccsid() too.
_ Since V7R4M0, procedure overloading is used to emulate limited "vararg-like"
  definitions of fetch_easy_setopt(), fetch_multi_setopt(), fetch_share_setopt()
  and fetch_easy_getinfo(). Blob and CCSID alternatives are NOT included in
  overloading.

  Since RPG cannot cast a long to a pointer, procedure fetch_form_long_value()
is provided for that purpose: this allows storing a long value in the
fetch_forms array. Please note the form API is deprecated and the MIME API
should be used instead.


CLI tool:

  The build system provides it as a bound program, an IFS link to it and a
simple CL command. The latter however is not able to provide a different
parameter for each option since there are too many of those; instead,
parameters are entered in a single field subject to quoting and escaping, in
the same form as expected by the standard CLI program.
  Care must be taken about the program output encoding: by default, it is sent
to the standard output and is thus subject to transcoding. It is therefore
recommended to use option "--output" to redirect output to a specific IFS file.
Similar problems may occur about the standard input encoding.
